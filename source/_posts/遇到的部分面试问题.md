---
title: 遇到的部分面试问题
date: 2019-03-09 23:28:22
tags:
---
- 说说es6新增内容  
- 扩展运算符扩展数组与对象  
- 箭头函数与bind有何不同
- node跨域的方法  
- 自适应不同分辨率  
- 前端优化  
  - link与import不同 
    - link属于XHTML标签，而@import是css提供的一种方式。
    - link标签除了可以加载css外，还可以做很多其他的事情，比如定义RSS，定义rel连接属性等，而		     @import只能加载css。
    - 加载顺序也不同。当一个页面被加载的时候，link引用的css会同时被加载，而@import引用的css		会等到页面全部被下载完再加载。
    - 兼容性的差别。@import ie5以上才能被支持。
    - 使用dom控制样式时的差别。link标签可用dom控制，@import不可。
    - @import可以在css中再次引入其他样式表，这样做有个缺点，会对服务器产生过多http请求。
- vue与react有何不同
- react性能优于vue
- vue用的模板，react用的jsx。
- react是在js里面写css
- 闭包，可能产生的问题以及解决方案
- vue组件通信
- 不同大小设备适配
- 基础类型与引用类型有哪些
- cookie与localstorage有什么区别
- 上下左右居中
- h5 'cover'了解多少
- transform与transition有什么区别
- 用transform写旋转怎么写
- 上传文件如何不刷新页面，ajax能上传文件吗？
- 如何做多人聊天，不使用websocket如何做实现长连接，使用定时器做长连接有什么问题（不考虑服务器资源方面）。
- h5中有什么能用于上传的新东西
  - XMLHttpRequest对象的第二版，从此ajax能够上传文件了，主要用的是FormData对象
  - XMLHttpRequest第二版还定义了一个progress事件，可以用来制作进度条。
  - 如果上传的是图片文件，利用File API可以做一个图片预览，主要用到FileReader对象。
- 有哪些新建对象的方式。
- 父子组件通信，非父子组件通信。
- Vue-router事件
- http状态码
- vuex的action和mutation有什么不同
- Vue router登录验证
- 异步组件
- ios，android有哪些兼容q问题
- 开发过哪些插件
- overflow hidden 去塌陷原理
  - 如果没有明确设定容器高情况下，它要计算内容全部高度才能确定在什么位置hidden，浮动的高度就要被计算进去，顺带达成了清理浮动的目标。独立的块级上下文可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，也就是说包含块会把浮动元素的高度也计算在内，所以不用清除浮动来撑起高度。
- 哪个期间能访问到vue实例里面的data
  - 创建后与销毁前
- computed与watch应用场景，与不同
  - computed有缓存，依赖项的值没变化时，结果调用不会变化
  - computed是计算属性，用起来就像data一样，watch是监听机制+事件机制，监听项发生变化的时候，然后执行对应事件的方法。
  - watch擅长处理的场景：一个数据影响多个数据；computed擅长处理的场景：一个数据受多个数据影响。
- get请求如何将#3发送到后台
  - url转码，#转为%23
- jquery on,bind，delegate，live不同
  - Live与delegate非常相似，实际上live内部使用的delegate来实现的，它们都监听事件的冒泡。delegate性能更高。
  - 新版本bind，delegate，live底层都是用on实现的。
- get post不同
- get产生一个TCP数据包，post产生两个TCP数据包
  - get会把header和data一并发送出去，服务器响应200；而post浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200。
  - get参数受限于url长度，具体数值取决于浏览器和服务器的限制，而post无限制。
- 浏览器内核
  - Trident --IE
  - Gecko -- Firefox
  - Webkit -- Safari
  - Chromium -- Chrome
  - Presto -- Opera
- json在堆栈里面的存储
  - 基本类型存在栈上面的
  - 引用类型存的值存在堆上面的，栈上面有引用地址
- Jquery的eq()
- Vue生命周期created和mounted的区别
- 闭包
- 数组，里面是对象，存的类似name,id等字段，如果根据价格排序。
  ​     ​		dt- sort((a, b) => {
  ​     ​		    return - price > - price ? 1 : -1
  ​     ​		})
- es6的新增的数组的方法。
  - Array的内置方法
    - From
    - Of
  - 实例的内置方法
    - copyWithin
    - find和findIndex
    - Fill
    - Entries,keys,values
    - Includes
    - Flat,flatMap
- 数组的sum()方法（数组没有sum方法，所以这问题是错误的）
- axios与ajax的区别（估计问的是jquery的ajax和axios的区别）
  - 从 nod- js 创建 http 请求
  - 支持 Promise API
  - 客户端支持防止CSRF
  - 提供了一些并发请求的接口
- tcp的实现
  - 首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。
  - 其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。
  - 最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。
- vue与jquery的有什么不同
  - jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。 
  - Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。
  - vue适用的场景：复杂数据操作的后台页面，表单填写页面
  - jquery适用的场景：比如说一些html5的动画页面，一些需要js来操作页面样式的页面
- 面向对象与面向过程的区别
  - 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
  - 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
- TCP与UDP的区别
  - TCP(传输控制协议 Transmission Control Protocol)
    - 提供IP环境下的数据可靠传输(一台计算机发出的字节流会无差错的发往网络上的其他计算机，而且计算机A接收数据包的时候，也会向计算机B回发数据包，这也会产生部分通信量)，有效流控，全双工操作(数据在两个方向上能同时传递)，多路复用服务，是面向连接，端到端的传输;
    - 面向连接：正式通信前必须要与对方建立连接。事先为所发送的数据开辟出连接好的通道，然后再进行数据发送，像打电话。
    - TCP支持的应用协议：Telnet(远程登录)、FTP(文件传输协议)、SMTP(简单邮件传输协议)。TCP用于传输数据量大，可靠性要求高的应用。
    - UDP(用户数据报协议，User Data Protocol)
      - 面向非连接的(正式通信前不必与对方建立连接，不管对方状态就直接发送，像短信，QQ)，不能提供可靠性、流控、差错恢复功能。UDP用于一次只传送少量数据，可靠性要求低、传输经济等应用。
      - UDP支持的应用协议：NFS(网络文件系统)、SNMP(简单网络管理系统)、DNS(主域名称系统)、TFTP(通用文件传输协议)等。
    - TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。
    - UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。
- 设计模式有哪些
  - 工厂模式——工厂模式是为了解决多个类似对象声明的问题;也就是为了解决实列化对象产生重复的问题。
    - 优点：能解决多个相似的问题。
    - 缺点：不能知道对象识别的问题(对象的类型不知道)。
  - 单体模式——单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。
    - 可以用来划分命名空间，减少全局变量的数量。
    - 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。
    - 可以被实例化，且实例化一次。
  - 模块模式
  - 代理模式
  - 职责链模式
  - 命令模式
  - 模板方法模式
  - 策略模式
  - 发布订阅模式
  - 中介者模式
    ​      ​    ​       ​            ​	
- 工厂模式有哪些好处
- 能解决多个相似的问题。
- vue.use()原理   
- require 与import区别
- 防抖动
-   prototype继承原理
    -   实例.__proto===构造函数.prototype
    -   查找实例的属性时，先判断自身有没有这个属性，如果有，那么直接获取；
    -   否则，查找它的__proto__有没有这个属性，如果有，就是它；
    -   否则，查找它的__proto__.__proto__有没有这个属性...
    -   如果一直找不到，就是undefined。